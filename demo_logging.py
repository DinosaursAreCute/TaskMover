"""
TaskMover Logging System Demonstration

This script demonstrates the capabilities of the TaskMover logging system
including different formatters, handlers, context management, and performance tracking.
"""

import tempfile
import time
from pathlib import Path

from taskmover.core.logging import get_logger, log_context
from taskmover.core.logging.config import (
    ConsoleConfig,
    FileConfig,
    FileRotationConfig,
    LoggingConfig,
    LogLevel,
)
from taskmover.core.logging.manager import LoggerManager
from taskmover.core.logging.utils import log_performance, performance_timer


def demonstrate_basic_logging():
    """Demonstrate basic logging functionality"""
    print("\nüöÄ === BASIC LOGGING DEMONSTRATION ===")

    # Get loggers for different components
    ui_logger = get_logger("ui.theme")
    core_logger = get_logger("core.application")
    file_logger = get_logger("file_ops.organizer")

    print("\nüìù Logging at different levels:")

    # UI Theme logging
    ui_logger.debug("üîç Debug: Theme system initializing...")
    ui_logger.info("‚ÑπÔ∏è Info: Successfully switched to dark theme")
    ui_logger.warning("‚ö†Ô∏è Warning: Custom theme file not found, using default")
    ui_logger.error("‚ùå Error: Failed to load theme configuration")

    # Core application logging
    core_logger.info(
        "üéØ Application startup sequence initiated",
        extra_data={
            "version": "1.0.0",
            "build": "2025.06.23",
            "startup_time": time.time(),
        },
    )

    # File operations logging
    file_logger.info(
        "üìÅ File organization started",
        extra_data={
            "source_directory": "/Users/example/Downloads",
            "rules_applied": 5,
            "files_to_process": 127,
        },
    )


def demonstrate_context_management():
    """Demonstrate logging context management"""
    print("\nüéØ === CONTEXT MANAGEMENT DEMONSTRATION ===")

    logger = get_logger("demo.context")

    print("\nüîó Using logging context for operation tracking:")

    # Demonstrate context manager
    with log_context(
        operation="file_batch_organization",
        user="demo_user",
        batch_id="batch_20250623_001",
        source_count=50,
    ):
        logger.info("üì¶ Starting batch file organization")
        logger.info("üîç Scanning source directory")
        logger.info("üìã Applied rules: extension_sort, date_organization")

        # Nested operation context
        with log_context(operation="pdf_processing", validator="adobe_preflight"):
            logger.info("üìÑ Processing PDF files")
            logger.warning("‚ö†Ô∏è PDF/A compliance issue detected")
            logger.info("‚úÖ PDF processing completed")

        logger.info("‚úÖ Batch organization completed successfully")

    logger.info("üßπ Operation context cleared")


def demonstrate_performance_tracking():
    """Demonstrate performance tracking"""
    print("\n‚ö° === PERFORMANCE TRACKING DEMONSTRATION ===")

    logger = get_logger("demo.performance")

    print("\n‚è±Ô∏è Performance timing with context manager:")

    # Performance timing context manager
    with log_performance("large_file_processing", logger, threshold_ms=10):
        time.sleep(0.05)  # Simulate 50ms operation
        logger.info("üóÇÔ∏è Processing large document archive")

    print("\nüéØ Performance timing with decorator:")

    # Performance timing decorator
    @performance_timer("file_sorting_algorithm", threshold_ms=1)
    def sort_files_by_date():
        """Simulate file sorting operation"""
        time.sleep(0.02)  # Simulate 20ms operation
        files = [f"document_{i:03d}.pdf" for i in range(1, 26)]
        return sorted(files)

    sorted_files = sort_files_by_date()
    logger.info(
        "üìä File sorting completed",
        extra_data={
            "files_sorted": len(sorted_files),
            "algorithm": "date_modified_desc",
        },
    )


def demonstrate_error_handling():
    """Demonstrate error handling and exception logging"""
    print("\nüö® === ERROR HANDLING DEMONSTRATION ===")

    logger = get_logger("demo.errors")

    print("\n‚ùå Simulating various error scenarios:")

    # Simulate file operation error
    try:
        raise FileNotFoundError("Source file 'important_document.pdf' not found")
    except Exception as e:
        logger.error(
            "üìÅ File operation failed",
            exception=e,
            extra_data={
                "operation": "copy_file",
                "source": "important_document.pdf",
                "destination": "/backup/documents/",
                "retry_count": 3,
            },
        )

    # Simulate permission error
    logger.error(
        "üîí Permission denied",
        extra_data={
            "operation": "create_directory",
            "path": "/restricted/system_files/",
            "required_permission": "write",
            "current_user": "demo_user",
        },
    )

    # Simulate critical system error
    logger.critical(
        "üí• Critical system error detected",
        extra_data={
            "error_type": "memory_exhaustion",
            "available_memory": "< 100MB",
            "process_count": 156,
            "action_taken": "emergency_cleanup",
        },
    )


def demonstrate_file_logging():
    """Demonstrate file logging with rotation"""
    print("\nüìÑ === FILE LOGGING DEMONSTRATION ===")

    print("\nüíæ Setting up file logging with rotation...")

    with tempfile.TemporaryDirectory() as temp_dir:
        log_file = Path(temp_dir) / "demo_application.log"

        # Create custom configuration for demonstration
        config = LoggingConfig(
            level=LogLevel.DEBUG,
            console=ConsoleConfig(enabled=True, colors=True, format="compact"),
            file=FileConfig(
                enabled=True,
                path=str(log_file),
                rotation=FileRotationConfig(
                    max_size="2KB",  # Very small for demo rotation
                    backup_count=3,
                    retention_days=1,
                    compression_enabled=False,  # Disabled for easy viewing
                ),
                format="detailed",
            ),
            components={"demo": LogLevel.DEBUG},
            session_tracking=True,
            performance_monitoring=True,
        )

        # Configure logging manager
        manager = LoggerManager()
        manager.configure(config)

        logger = get_logger("demo.file_logging")

        # Generate logs to trigger rotation
        print("üìù Generating log entries to demonstrate rotation...")
        for i in range(15):
            logger.info(
                f"üìã Log entry {i+1:02d}: Processing item batch with detailed information about the operation",
                extra_data={
                    "batch_number": i + 1,
                    "items_processed": (i + 1) * 10,
                    "status": "active",
                },
            )

            if (i + 1) % 5 == 0:
                logger.warning(
                    f"‚ö†Ô∏è Checkpoint {i+1}: Memory usage increasing",
                    extra_data={"memory_usage_mb": 150 + (i * 10), "threshold_mb": 500},
                )

        # IMPORTANT: Shutdown logging first to close file handles
        print("üîí Shutting down logging system...")
        manager.shutdown()

        # Small delay to ensure files are properly closed on Windows
        time.sleep(0.1)

        # Show file system results
        print("\nüìä File logging results:")
        print(f"   Log file: {log_file}")

        if log_file.exists():
            try:
                file_size = log_file.stat().st_size
                print(f"   File size: {file_size} bytes")

                # Check for rotated files
                backup_files = list(log_file.parent.glob(f"{log_file.name}.*"))
                print(f"   Backup files created: {len(backup_files)}")

                for backup in sorted(backup_files):
                    try:
                        backup_size = backup.stat().st_size
                        print(f"     {backup.name}: {backup_size} bytes")
                    except Exception as e:
                        print(f"     {backup.name}: <size unavailable - {e}>")

                # Show last few lines of current log with proper encoding
                try:
                    content = log_file.read_text(encoding="utf-8")
                    lines = content.strip().split("\n")
                    print(f"   Total lines in current log: {len(lines)}")
                    print("   üìÑ Last 3 log entries:")
                    for line in lines[-3:]:
                        if line.strip():
                            print(f"     {line}")
                except UnicodeDecodeError:
                    # Fallback to binary read if UTF-8 fails
                    print("   üìÑ Log content (binary mode due to encoding issues):")
                    with open(log_file, "rb") as f:
                        content = f.read()
                        print(f"     File contains {len(content)} bytes")
                except Exception as e:
                    print(f"   ‚ö†Ô∏è Could not read log content: {e}")

            except Exception as e:
                print(f"   ‚ö†Ô∏è Error accessing log file: {e}")
        else:
            print("   ‚ö†Ô∏è Log file was not created")


def demonstrate_component_filtering():
    """Demonstrate component-specific log filtering"""
    print("\nüè∑Ô∏è === COMPONENT FILTERING DEMONSTRATION ===")

    print("\nüéØ Different components with different log levels:")

    # Get loggers for different components
    ui_logger = get_logger("ui.components")
    core_logger = get_logger("core.engine")
    debug_logger = get_logger("debug.trace")
    build_logger = get_logger("build.assets")

    # UI component messages (typically INFO+)
    ui_logger.debug("üîç UI Debug: Button hover state changed")  # May be filtered
    ui_logger.info("‚ÑπÔ∏è UI Info: Modal dialog opened")
    ui_logger.warning("‚ö†Ô∏è UI Warning: Accessibility issue detected")

    # Core engine messages (typically INFO+)
    core_logger.debug("üîç Core Debug: Internal state updated")  # May be filtered
    core_logger.info("‚ÑπÔ∏è Core Info: Task engine started")
    core_logger.error("‚ùå Core Error: Task execution failed")

    # Debug component (typically DEBUG+)
    debug_logger.debug("üîç Debug Trace: Variable state dump")
    debug_logger.info("‚ÑπÔ∏è Debug Info: Breakpoint reached")

    # Build component (typically WARNING+ only)
    build_logger.debug("üîç Build Debug: Asset hashing")  # Likely filtered
    build_logger.info("‚ÑπÔ∏è Build Info: Compiling assets")  # Likely filtered
    build_logger.warning("‚ö†Ô∏è Build Warning: Asset size large")
    build_logger.error("‚ùå Build Error: Asset compilation failed")


def main():
    """Run all demonstrations"""
    print("üéâ TaskMover Logging System Demonstration")
    print("=" * 65)
    print("This demo shows the comprehensive logging capabilities of TaskMover")

    try:
        demonstrate_basic_logging()
        demonstrate_context_management()
        demonstrate_performance_tracking()
        demonstrate_error_handling()
        demonstrate_file_logging()
        demonstrate_component_filtering()

        print("\n" + "=" * 65)
        print("üèÜ Demonstration completed successfully!")
        print("\n‚ú® The TaskMover logging system provides:")
        print("   ‚Ä¢ üìä Multiple output formats (console, file, JSON)")
        print("   ‚Ä¢ üé® Colored console output with emojis")
        print("   ‚Ä¢ üîÑ Automatic log rotation and cleanup")
        print("   ‚Ä¢ üéØ Component-based filtering")
        print("   ‚Ä¢ üîó Context management for operation tracking")
        print("   ‚Ä¢ ‚ö° Performance monitoring and timing")
        print("   ‚Ä¢ üö® Comprehensive error handling")
        print("   ‚Ä¢ üõ°Ô∏è Thread-safe singleton architecture")
        print("   ‚Ä¢ ‚öôÔ∏è Configurable via YAML files")
        print("\nüöÄ Ready for production use in TaskMover!")

    except Exception as e:
        print(f"\nüí• Demonstration failed: {e}")
        import traceback

        traceback.print_exc()
        return 1

    return 0


if __name__ == "__main__":
    exit(main())
